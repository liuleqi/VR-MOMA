/**
 * Generated by Verge3D Puzzles v.3.3.0
 * Tue Nov 17 2020 17:38:32 GMT+0800 (中国标准时间)
 * Prefer not editing this file as your changes may get overridden once Puzzles are saved.
 * Check out https://www.soft8soft.com/docs/manual/en/introduction/Using-JavaScript.html
 * for the information on how to add your own JavaScript to Verge3D apps.
 */

'use strict';

(function() {

// global variables/constants used by puzzles' functions
var _pGlob = {};

_pGlob.objCache = {};
_pGlob.fadeAnnotations = true;
_pGlob.objClickCallbacks = [];
_pGlob.pickedObject = '';
_pGlob.objHoverCallbacks = [];
_pGlob.hoveredObject = '';
_pGlob.objMovementInfos = {};
_pGlob.objDragOverCallbacks = [];
_pGlob.objDragOverInfoByBlock = {}
_pGlob.dragMoveOrigins = {};
_pGlob.dragScaleOrigins = {};
_pGlob.mediaElements = {};
_pGlob.loadedFiles = {};
_pGlob.loadedFile = '';
_pGlob.promiseValue = '';
_pGlob.animMixerCallbacks = [];
_pGlob.arHitPoint = new v3d.Vector3(0, 0, 0);
_pGlob.states = [];
_pGlob.percentage = 0;
_pGlob.animateParamUpdate = null;
_pGlob.openedFile = '';
_pGlob.xrSessionAcquired = false;
_pGlob.xrSessionCallbacks = [];
_pGlob.screenCoords = new v3d.Vector2();
_pGlob.gamepadIndex = 0;

_pGlob.AXIS_X = new v3d.Vector3(1, 0, 0);
_pGlob.AXIS_Y = new v3d.Vector3(0, 1, 0);
_pGlob.AXIS_Z = new v3d.Vector3(0, 0, 1);
_pGlob.MIN_DRAG_SCALE = 10e-4;
_pGlob.SET_OBJ_ROT_EPS = 1e-8;

_pGlob.vec2Tmp = new v3d.Vector2();
_pGlob.vec2Tmp2 = new v3d.Vector2();
_pGlob.vec3Tmp = new v3d.Vector3();
_pGlob.vec3Tmp2 = new v3d.Vector3();
_pGlob.vec3Tmp3 = new v3d.Vector3();
_pGlob.vec3Tmp4 = new v3d.Vector3();
_pGlob.eulerTmp = new v3d.Euler();
_pGlob.eulerTmp2 = new v3d.Euler();
_pGlob.quatTmp = new v3d.Quaternion();
_pGlob.quatTmp2 = new v3d.Quaternion();
_pGlob.colorTmp = new v3d.Color();
_pGlob.mat4Tmp = new v3d.Matrix4();
_pGlob.planeTmp = new v3d.Plane();
_pGlob.raycasterTmp = new v3d.Raycaster();
_pGlob.intervals = {};

_pGlob.wooProductInfo = {};

var _pPhysics = {};

_pPhysics.tickCallbacks = [];
_pPhysics.syncList = [];

// internal info
_pPhysics.collisionData = [];

// goes to collision callback
_pPhysics.collisionInfo = {
    objectA: '',
    objectB: '',
    distance: 0,
    positionOnA: [0, 0, 0],
    positionOnB: [0, 0, 0],
    normalOnB: [0, 0, 0]
};

var PL = v3d.PL = v3d.PL || {};

// a more readable alias for PL (stands for "Puzzle Logic")
v3d.puzzles = PL;

PL.procedures = PL.procedures || {};

PL.execInitPuzzles = function(options) {
    // always null, should not be available in "init" puzzles
    var appInstance = null;

    var _initGlob = {};
    _initGlob.percentage = 0;
    _initGlob.output = {
        initOptions: {
            fadeAnnotations: true,
            useBkgTransp: false,
            preserveDrawBuf: false,
            useCompAssets: false,
            useFullscreen: true,
            useCustomPreloader: false,
            preloaderStartCb: function() {},
            preloaderProgressCb: function() {},
            preloaderEndCb: function() {},
        }
    }

    // provide the container's id to puzzles that need access to the container
    _initGlob.container = options !== undefined && 'container' in options
            ? options.container : "";

    

    
// utility functions envoked by the HTML puzzles
function getElements(ids, isParent) {
    var elems = [];
    if (Array.isArray(ids) && ids[0] != 'CONTAINER' && ids[0] != 'WINDOW' &&
        ids[0] != 'DOCUMENT' && ids[0] != 'BODY' && ids[0] != 'QUERYSELECTOR') {
        for (var i = 0; i < ids.length; i++)
            elems.push(getElement(ids[i], isParent));
    } else {
        elems.push(getElement(ids, isParent));
    }
    return elems;
}

function getElement(id, isParent) {
    var elem;
    if (Array.isArray(id) && id[0] == 'CONTAINER') {
        if (appInstance !== null) {
            elem = appInstance.container;
        } else if (typeof _initGlob !== 'undefined') {
            // if we are on the initialization stage, we still can have access
            // to the container element
            var id = _initGlob.container;
            if (isParent) {
                elem = parent.document.getElementById(id);
            } else {
                elem = document.getElementById(id);
            }
        }
    } else if (Array.isArray(id) && id[0] == 'WINDOW') {
        if (isParent)
            elem = parent;
        else
            elem = window;
    } else if (Array.isArray(id) && id[0] == 'DOCUMENT') {
        if (isParent)
            elem = parent.document;
        else
            elem = document;
    } else if (Array.isArray(id) && id[0] == 'BODY') {
        if (isParent)
            elem = parent.document.body;
        else
            elem = document.body;
    } else if (Array.isArray(id) && id[0] == 'QUERYSELECTOR') {
        if (isParent)
            elem = parent.document.querySelector(id);
        else
            elem = document.querySelector(id);
    } else {
        if (isParent)
            elem = parent.document.getElementById(id);
        else
            elem = document.getElementById(id);
    }
    return elem;
}



// setHTMLElemStyle puzzle
function setHTMLElemStyle(prop, value, ids, isParent) {
    var elems = getElements(ids, isParent);
    for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (!elem || !elem.style)
            continue;
        elem.style[prop] = value;
    }
}




// initSettings puzzle
_initGlob.output.initOptions.fadeAnnotations = true;
_initGlob.output.initOptions.useBkgTransp = false;
_initGlob.output.initOptions.preserveDrawBuf = false;
_initGlob.output.initOptions.useCompAssets = false;
_initGlob.output.initOptions.useFullscreen = false;


// initPreloader puzzle
_initGlob.output.initOptions.useCustomPreloader = true;
_initGlob.output.initOptions.preloaderStartCb = function() {
    _initGlob.percentage = 0;
    (function() {
  setHTMLElemStyle('display', 'block', 'preloader', false);
  setHTMLElemStyle('width', '0%', 'preloader_bar', false);
})();
};
_initGlob.output.initOptions.preloaderProgressCb = function(percentage) {
    _initGlob.percentage = percentage;
    (function() {
  setHTMLElemStyle('width', String(Math.round(_initGlob.percentage)) + '%', 'preloader_bar', false);
})();
};
_initGlob.output.initOptions.preloaderEndCb = function() {
    _initGlob.percentage = 100;
    (function() {
  setHTMLElemStyle('display', 'none', 'preloader', false);
})();
};

    return _initGlob.output;
}

PL.init = function(appInstance, initOptions) {
initOptions = initOptions || {};

if ('fadeAnnotations' in initOptions) {
    _pGlob.fadeAnnotations = initOptions.fadeAnnotations;
}

this.procedures["ModelOrbit"] = ModelOrbit;
this.procedures["ModelFirstPerson"] = ModelFirstPerson;
this.procedures["ModelVr"] = ModelVr;
this.procedures["Click_Object"] = Click_Object;
this.procedures["Into_Room1"] = Into_Room1;
this.procedures["MoveForward"] = MoveForward;
this.procedures["MoveBack"] = MoveBack;
this.procedures["Into_Room2"] = Into_Room2;
this.procedures["MoveLeft"] = MoveLeft;
this.procedures["StartPreloader"] = StartPreloader;
this.procedures["UpdatePreloader"] = UpdatePreloader;
this.procedures["EndPreloader"] = EndPreloader;
this.procedures["MoveRight"] = MoveRight;
this.procedures["Description"] = Description;

var doors, mode_type, objName, velocity, params, percenage, obj, description, play, vr_available, move_speed, video1, video2;



// utility function envoked by almost all V3D-specific puzzles
// filter off some non-mesh types
function notIgnoredObj(obj) {
    return (obj.type !== "AmbientLight" && obj.name !== ""
            && !(obj.isMesh && obj.isMaterialGeneratedMesh));
}


// utility function envoked by almost all V3D-specific puzzles
// find first occurence of the object by its name
function getObjectByName(objName) {
    var objFound;
    var runTime = _pGlob !== undefined;
    objFound = runTime ? _pGlob.objCache[objName] : null;

    if (objFound && objFound.name === objName)
        return objFound;

    appInstance.scene.traverse(function(obj) {
        if (!objFound && notIgnoredObj(obj) && (obj.name == objName)) {
            objFound = obj;
            if (runTime) {
                _pGlob.objCache[objName] = objFound;
            }
        }
    });
    return objFound;
}


// utility function envoked by almost all V3D-specific puzzles
// retrieve all objects on the scene
function getAllObjectNames() {
    var objNameList = [];
    appInstance.scene.traverse(function(obj) {
        if (notIgnoredObj(obj))
            objNameList.push(obj.name)
    });
    return objNameList;
}


// utility function envoked by almost all V3D-specific puzzles
// retrieve all objects which belong to the group
function getObjectNamesByGroupName(targetGroupName) {
    var objNameList = [];
    appInstance.scene.traverse(function(obj){
        if (notIgnoredObj(obj)) {
            var groupNames = obj.groupNames;
            if (!groupNames)
                return;
            for (var i = 0; i < groupNames.length; i++) {
                var groupName = groupNames[i];
                if (groupName == targetGroupName) {
                    objNameList.push(obj.name);
                }
            }
        }
    });
    return objNameList;
}


// utility function envoked by almost all V3D-specific puzzles
// process object input, which can be either single obj or array of objects, or a group
function retrieveObjectNames(objNames) {
    var acc = [];
    retrieveObjectNamesAcc(objNames, acc);
    return acc;
}

function retrieveObjectNamesAcc(currObjNames, acc) {
    if (typeof currObjNames == "string") {
        acc.push(currObjNames);
    } else if (Array.isArray(currObjNames) && currObjNames[0] == "GROUP") {
        var newObj = getObjectNamesByGroupName(currObjNames[1]);
        for (var i = 0; i < newObj.length; i++)
            acc.push(newObj[i]);
    } else if (Array.isArray(currObjNames) && currObjNames[0] == "ALL_OBJECTS") {
        var newObj = getAllObjectNames();
        for (var i = 0; i < newObj.length; i++)
            acc.push(newObj[i]);
    } else if (Array.isArray(currObjNames)) {
        for (var i = 0; i < currObjNames.length; i++)
            retrieveObjectNamesAcc(currObjNames[i], acc);
    }
}




// outline puzzle
function outline(objNames, doWhat) {
    objNames = retrieveObjectNames(objNames);
    if (!objNames)
        return;
    if (!appInstance.postprocessing || !appInstance.postprocessing.outlinePass)
        return;
    var outlineArray = appInstance.postprocessing.outlinePass.selectedObjects;
    for (var i = 0; i < objNames.length; i++) {
        var objName = objNames[i];
        var obj = getObjectByName(objName);
        if (!obj)
            continue;
        if (doWhat == "ENABLE") {
            if (outlineArray.indexOf(obj) == -1)
                outlineArray.push(obj);
        } else {
            var index = outlineArray.indexOf(obj);
            if (index > -1)
                outlineArray.splice(index, 1);
        }
    }
}



// appendScene puzzle
function appendScene(url, sceneName, loadCameras, loadLights, loadCb, progCb) {
    _pGlob.percentage = 0;

    appInstance.appendScene(url, function(loadedScene) {
        loadedScene.name = sceneName;
        _pGlob.percentage = 100;
        loadCb();
    }, function(percentage) {
        _pGlob.percentage = percentage;
        progCb();
    }, null, loadCameras, loadLights);
}



// callJSFunction puzzle
function getJSFunction(funcName) {
    var jsFunc = appInstance.ExternalInterface[funcName];
    if (typeof jsFunc == "function")
        return jsFunc;
    else
        return function() {};
}



// utility function used by the whenClicked, whenHovered and whenDraggedOver puzzles
function initObjectPicking(callback, eventType, mouseDownUseTouchStart) {

    var elem = appInstance.renderer.domElement;
    elem.addEventListener(eventType, pickListener);
    if (eventType == "mouseup") {
        var touchEventName = mouseDownUseTouchStart ? "touchstart" : "touchend";
        elem.addEventListener(touchEventName, pickListener);
    }

    var raycaster = new v3d.Raycaster();
    function pickListener(event) {
        event.preventDefault();

        var xNorm = 0, yNorm = 0;
        if (event instanceof MouseEvent) {
            xNorm = event.offsetX / elem.clientWidth;
            yNorm = event.offsetY / elem.clientHeight;
        } else if (event instanceof TouchEvent) {
            var rect = elem.getBoundingClientRect();
            xNorm = (event.changedTouches[0].clientX - rect.left) / rect.width;
            yNorm = (event.changedTouches[0].clientY - rect.top) / rect.height;
        }

        _pGlob.screenCoords.x = xNorm * 2 - 1;
        _pGlob.screenCoords.y = -yNorm * 2 + 1;
        raycaster.setFromCamera(_pGlob.screenCoords, appInstance.camera);
        var objList = [];
        appInstance.scene.traverse(function(obj){objList.push(obj);});
        var intersects = raycaster.intersectObjects(objList);
        if (intersects.length > 0) {
            var obj = intersects[0].object;
            callback(obj, event);
        } else {
            callback(null, event);
        }
    }
}

// utility function used by the whenDraggedOver puzzles
function fireObjectPickingCallbacks(objName, source, index, cbParam) {
    for (var i = 0; i < source.length; i++) {
        var cb = source[i];
        if (objectsIncludeObj([cb[0]], objName)) {
            cb[index](cbParam);
        }
    }
}

function objectsIncludeObj(objNames, testedObjName) {
    if (!testedObjName) return false;

    for (var i = 0; i < objNames.length; i++) {
        if (testedObjName == objNames[i]) {
            return true;
        } else {
            // also check children which are auto-generated for multi-material objects
            var obj = getObjectByName(objNames[i]);
            if (obj && obj.type == "Group") {
                for (var j = 0; j < obj.children.length; j++) {
                    if (testedObjName == obj.children[j].name) {
                        return true;
                    }
                }
            }
        }
    }
    return false;
}

// utility function used by the whenClicked, whenHovered and whenDraggedOver puzzles
function getPickedObjectName(obj) {
    // auto-generated from a multi-material object, use parent name instead
    if (obj.isMesh && obj.isMaterialGeneratedMesh && obj.parent) {
        return obj.parent.name;
    } else {
        return obj.name;
    }
}



// whenClicked puzzle
initObjectPicking(function(obj) {

    // save the object for the pickedObject block
    _pGlob.pickedObject = obj ? getPickedObjectName(obj) : '';

    _pGlob.objClickCallbacks.forEach(function(el) {
        var isPicked = obj && objectsIncludeObj(el.objNames, getPickedObjectName(obj));
        el.callbacks[isPicked ? 0 : 1]();
    });
}, 'mouseup');



// whenClicked puzzle
function registerOnClick(objNames, cbDo, cbIfMissedDo) {
    objNames = retrieveObjectNames(objNames) || [];
    var objNamesFiltered = objNames.filter(function(name) {
        return name;
    });
    _pGlob.objClickCallbacks.push({
        objNames: objNamesFiltered,
        callbacks: [cbDo, cbIfMissedDo]
    });
}



// snapToObject puzzle
function snapToObject(objName, targetObjName) {
    if (!objName || !targetObjName)
        return;
    var obj = getObjectByName(objName);
    var targetObj = getObjectByName(targetObjName);
    if (!obj || !targetObj)
        return;
    obj.copyTransform(targetObj);
    obj.updateMatrixWorld(true);
}



// makeParent puzzle
function makeParent(objName, targetObjName) {
    if (!objName)
        return;
    var obj = getObjectByName(objName);
    if (!obj)
        return;
    if (targetObjName) {
        var targetObj = getObjectByName(targetObjName);
        if (!targetObj)
            return;
    } else {
        obj.traverseAncestors(function(ancObj) {
            if (ancObj.type == "Scene")
                targetObj = ancObj;
        });
    }
    var matOffset = new v3d.Matrix4();
    matOffset.getInverse(targetObj.matrixWorld);
    matOffset.multiply(obj.matrixWorld);
    matOffset.decompose(obj.position, obj.quaternion, obj.scale);
    targetObj.add(obj);

    obj.updateMatrixWorld(true);
}



// checkVRMode puzzle
function checkVRMode(availableCb, unAvailableCb) {
    // COMPAT: < 2.13.1
    if (v3d.Detector.checkWebXR)
        v3d.Detector.checkWebXR('immersive-vr', availableCb, unAvailableCb);
    else
        appInstance.checkWebXR('immersive-vr', availableCb, unAvailableCb);
}



// featureAvailable puzzle
function featureAvailable(feature) {

    var userAgent = window.navigator.userAgent;
    var platform = window.navigator.platform;

    switch (feature) {
    case 'LINUX':
        return /Linux/.test(platform);
    case 'WINDOWS':
        return ['Win32', 'Win64', 'Windows', 'WinCE'].indexOf(platform) !== -1;
    case 'MACOS':
        return (['Macintosh', 'MacIntel', 'MacPPC', 'Mac68K'].indexOf(platform) !== -1 && !v3d.Detector.checkIOS());
    case 'IOS':
        return v3d.Detector.checkIOS();
    case 'ANDROID':
        return /Android/i.test(userAgent);
    case 'MOBILE':
        return (/Android|webOS|BlackBerry/i.test(userAgent) || v3d.Detector.checkIOS());

    case 'CHROME':
        // Chromium based
        return (!!window.chrome && !/Edge/.test(navigator.userAgent));
    case 'FIREFOX':
        return /Firefox/.test(navigator.userAgent);
    case 'IE':
        return /Trident/.test(navigator.userAgent);
    case 'EDGE':
        return /Edge/.test(navigator.userAgent);
    case 'SAFARI':
        return (/Safari/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent));

    case 'TOUCH':
        return !!(('ontouchstart' in window) || window.DocumentTouch && document instanceof DocumentTouch);
    case 'RETINA':
        return window.devicePixelRatio >= 2;
    case 'HDR':
        return appInstance.useHDR;
    case 'WEBGL2':
        var canvas = document.createElement('canvas');
        var gl = canvas.getContext('webgl2')
        return !!gl;
    case 'WOOCOMMERCE':
        var woo_fun = window.parent.v3d_woo_get_product_info || window.parent.parent.v3d_woo_get_product_info;
        return !!woo_fun;
    default:
        return false;
    }

}



function setScreenScale(factor) {
    appInstance.renderer.setPixelRatio(factor);
    // to update possible post-processing passes
    appInstance.onResize();
}



// setActiveCamera puzzle
function setActiveCamera(camName) {
    var camera = getObjectByName(camName);
    if (!camera || !camera.isCamera || appInstance.camera == camera)
        return;
    appInstance.setCamera(camera);
}


// Describe this function...
function ModelOrbit() {
  if (mode_type != 'orbit') {
    mode_type = 'orbit';
    setActiveCamera('Camera_orbit');
    appInstance.endWebXR();
  }
}

// Describe this function...
function ModelFirstPerson() {
  if (mode_type != 'firstPerson') {
    mode_type = 'firstPerson';
    setActiveCamera('Camera_fps');
    appInstance.endWebXR();
  }
}


_pGlob.getInputSource = function(controller) {
    if (controller && controller.userData.v3d && controller.userData.v3d.inputSource) {
        return controller.userData.v3d.inputSource
    } else {
        return null;
    }
};

_pGlob.traverseNonControllers = function(obj, callback) {

    if (obj.name.startsWith('XR_CONTROLLER_'))
        return;

    callback(obj);

    var children = obj.children;

    for (var i = 0, l = children.length; i < l; i++) {

        _pGlob.traverseNonControllers(children[i], callback);

    }

};

_pGlob.xrGetIntersections = function(controller) {

    controller.updateMatrixWorld(true);

    _pGlob.mat4Tmp.identity().extractRotation(controller.matrixWorld);

    var objList = [];

    _pGlob.traverseNonControllers(appInstance.scene, function(obj) {
        objList.push(obj);
    });

    var raycaster = new v3d.Raycaster();
    raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
    raycaster.ray.direction.set(0, 0, -1).applyMatrix4(_pGlob.mat4Tmp);

    return raycaster.intersectObjects(objList);

}

_pGlob.xrOnSelect = function(event) {

    var controller = event.target;

    var intersections = _pGlob.xrGetIntersections(controller);

    if (intersections.length > 0) {
        var intersection = intersections[0];
        var obj = intersection.object;

        // save the object for the pickedObject block
        _pGlob.pickedObject = getPickedObjectName(obj);

        _pGlob.objClickCallbacks.forEach(function(el) {
            var isPicked = obj && objectsIncludeObj(el.objNames, getPickedObjectName(obj));
            el.callbacks[isPicked ? 0 : 1]();
        });
    } else {
        _pGlob.objClickCallbacks.forEach(function(el) {
            // missed
            el.callbacks[1]();
        });
    }

}



// enterVRMode puzzle
function enterVRMode(refSpace, enterCb, exitCb, unAvailableCb) {

    var DEFAULT_DEPTH = 10;

    var _rayReticleDepth = [];
    var _hoveredObjects = [];

    function onControllerHover() {

        var controllers = appInstance.xrControllers;

        for (var i = 0; i < controllers.length; i++) {
            var controller = controllers[i];

            var intersections = _pGlob.xrGetIntersections(controller);

            if (intersections.length > 0) {
                var intersection = intersections[0];
                var obj = intersection.object;
                _rayReticleDepth[i] = intersection.distance;
            } else {
                var obj = null;
                _rayReticleDepth[i] = DEFAULT_DEPTH;
            }

            controller.children.forEach(function(child) {
                if (child.name.indexOf('_RAY') > -1) {
                    child.scale.z = _rayReticleDepth[i];
                } else if (child.name.indexOf('_RETICLE') > -1) {
                    // reduces crossing artefacts
                    child.position.z = -0.95 * _rayReticleDepth[i];
                }
            });

            var prevHovered = _hoveredObjects[i];
            var currHovered = obj ? getPickedObjectName(obj) : '';

            if (prevHovered == currHovered) {
                continue;
            }

            // first - all "out" callbacks, then - all "over"
            _pGlob.objHoverCallbacks.forEach(function(el) {
                if (objectsIncludeObj(el.objNames, prevHovered)) {
                    // ensure the correct value of the hoveredObject block
                    _pGlob.hoveredObject = prevHovered;
                    el.callbacks[1]();
                }
            });

            _pGlob.objHoverCallbacks.forEach(function(el) {
                if (objectsIncludeObj(el.objNames, currHovered)) {
                    // ensure the correct value of the hoveredObject block
                    _pGlob.hoveredObject = currHovered;
                    el.callbacks[0]();
                }
            });

            _hoveredObjects[i] = currHovered;
        }
    }

    switch (refSpace) {
        case 'SITTING':
            var referenceSpace = 'local-floor';
            break;
        case 'WALKING':
            var referenceSpace = 'unbounded';
            break;
        case 'ORIGIN':
            var referenceSpace = 'local';
            break;
        case 'ROOM':
            var referenceSpace = 'bounded-floor';
            break;
        case 'VIEWER':
            var referenceSpace = 'viewer';
            break;
        default:
            console.error('puzzles: Wrong VR reference space');
            return;
    }

    appInstance.initWebXR('immersive-vr', referenceSpace, function() {

        var controllers = appInstance.xrControllers;

        for (var i = 0; i < controllers.length; i++) {
            var controller = controllers[i];

            // clicks
            controller.addEventListener('select', _pGlob.xrOnSelect);

            _pGlob.xrSessionCallbacks.forEach(function(pair) {
                controller.addEventListener(pair[0], pair[1]);
            });
        }

        // hovers
        if (_pGlob.objHoverCallbacks.length && appInstance.renderCallbacks.indexOf(onControllerHover) == -1)
            appInstance.renderCallbacks.push(onControllerHover);

        _pGlob.xrSessionAcquired = true;

        enterCb();

    }, unAvailableCb, function() {

        var controllers = appInstance.xrControllers;

        for (var i = 0; i < controllers.length; i++) {
            var controller = controllers[i];

            controller.removeEventListener('select', _pGlob.xrOnSelect);

            _pGlob.xrSessionCallbacks.forEach(function(pair) {
                controller.removeEventListener(pair[0], pair[1]);
            });
        }

        var cbIdx = appInstance.renderCallbacks.indexOf(onControllerHover);
        if (cbIdx != -1)
            appInstance.renderCallbacks.splice(cbIdx, 1);

        _pGlob.xrSessionAcquired = false;

        exitCb();
    });
}


// Describe this function...
function ModelVr() {
  if (mode_type != 'vr') {
    mode_type = 'vr';
    if (vr_available) {
      setActiveCamera('Camera_vr');
      enterVRMode('SITTING', function() {
        console.log('VR MODE ON');
      }, function() {
        console.log('VR MODE OFF');
      }, function() {
        console.log('NO VR');
      });
    } else {
      console.log('vr_available = false');
      getJSFunction('vrAlert')(!vr_available);
    }
  }
}


// stopSound puzzle
function stopSound(audioElem) {
    if (!audioElem) {
        return;
    }
    audioElem.pause();
    audioElem.currentTime = 0;
}


// Describe this function...
function Click_Object(objName) {
  if (objName == 'doorC' || objName == 'doorA' || objName == 'doorB') {
    StartPreloader();
    Into_Room2();
    stopSound(video1);
  } else if (objName == 'door_1' || objName == 'door_2' || objName == 'door_3' || objName == 'door_4') {
    StartPreloader();
    Into_Room1();
    stopSound(video2);
  }
}


// createVector puzzle
function createVector(x, y, z) {
    return [x, y, z];
};



// unloadScene puzzle
function unloadScene(url) {
    if (appInstance.scene) {
        var scene = url === '' ? appInstance.scene : appInstance.scene.getObjectByName(url);
        if (scene) appInstance.unload(scene);

        if (!appInstance.scene) appInstance.renderer.clear();

        // clean object cache
        _pGlob.objCache = {};
    }
}



/**
 * Find physics body associated with the given object and remove it.
 */
_pPhysics.findRemovePhysicsBody = function(obj) {

    for (var i = 0; i < _pPhysics.syncList.length; i++) {
        var syncData = _pPhysics.syncList[i];

        if (syncData.obj == obj) {
            _pPhysics.world.removeRigidBody(syncData.body);
            Ammo.destroy(syncData.body);
            _pPhysics.syncList.splice(i, 1);
            i--;
        }
    }
}

/**
 * Cleanup forces and velocities
 */
_pPhysics.resetBody = function(body) {
    body.clearForces();

    var zeroVec = new Ammo.btVector3(0, 0, 0);

    body.setLinearVelocity(zeroVec);
    body.setAngularVelocity(zeroVec);
}

_pPhysics.setObjToBodyTransform = function(obj, body) {
    var pos = obj.getWorldPosition(_pGlob.vec3Tmp);
    var quat = obj.getWorldQuaternion(_pGlob.quatTmp);

    _pPhysics.transTmp.setIdentity();
    _pPhysics.transTmp.setOrigin(new Ammo.btVector3(pos.x, pos.y, pos.z));
    _pPhysics.transTmp.setRotation(new Ammo.btQuaternion(quat.x, quat.y, quat.z, quat.w));

    body.setWorldTransform(_pPhysics.transTmp);
    body.getMotionState().setWorldTransform(_pPhysics.transTmp);
}



// removePhysicsBody puzzle
function removePhysicsBody(objNames) {

    objNames = retrieveObjectNames(objNames);
    if (!objNames)
        return;

    objNames.forEach(function(objName) {
        if (!objName)
            return;

        var obj = getObjectByName(objName);
        if (!obj)
            return;

        _pPhysics.findRemovePhysicsBody(obj);

    });

}



// createPhysicsBody puzzle
function createPhysicsBody(type, objNames, shape, mass) {

    if (!window.Ammo)
        return;

    objNames = retrieveObjectNames(objNames);
    if (!objNames)
        return;

    objNames.forEach(function(objName) {
        if (!objName)
            return;

        var obj = getObjectByName(objName);
        if (!obj)
            return;

        _pPhysics.findRemovePhysicsBody(obj);

        switch (shape) {
        case 'BOX':
        case 'CAPSULE':
        case 'CONE':
        case 'CYLINDER':

            var box = new v3d.Box3();

            obj.resolveMultiMaterial().forEach(function(objR) {
                if (objR.geometry) {
                    if (objR.geometry.boundingBox == null)
                        objR.geometry.computeBoundingBox();

                    box.union(objR.geometry.boundingBox);
                }
            });

            var size = box.getSize(new v3d.Vector3());

            // do not allow empty-sized shapes
            size.x = size.x || 0.5;
            size.y = size.y || 0.5;
            size.z = size.z || 0.5;

            if (shape == 'BOX') {
                var geometry = new Ammo.btBoxShape(new Ammo.btVector3(
                        size.x * 0.5, size.y * 0.5, size.z * 0.5));
            } else if (shape == 'CAPSULE') {
                var radius = Math.max(size.x, size.z) * 0.5;
                var height = size.y - 2 * radius;
                var geometry = new Ammo.btCapsuleShape(radius, height);
            } else if (shape == 'CONE') {
                var radius = Math.max(size.x, size.z) * 0.5;
                var height = size.y;
                var geometry = new Ammo.btConeShape(radius, height);
            } else {
                var geometry = new Ammo.btCylinderShape(new Ammo.btVector3(
                        size.x * 0.5, size.y * 0.5, size.z * 0.5));
            }

            break;
        case 'SPHERE':

            var sphere = new v3d.Sphere();

            obj.resolveMultiMaterial().forEach(function(objR) {

                if (objR.geometry) {
                    if (objR.geometry.boundingSphere === null)
                        objR.geometry.computeBoundingSphere();

                    sphere.union(objR.geometry.boundingSphere);
                }
            });

            var geometry = new Ammo.btSphereShape(sphere.radius || 0.5);

            break;
        case 'MESH':

            var objsR = obj.resolveMultiMaterial();

            if (!objsR[0].geometry || !objsR[0].isMesh) {
                console.error('create physics body: incorrect mesh object');
                var geometry = new Ammo.btEmptyShape();
                break;
            }

            if (type != 'STATIC') {

                var geometry = new Ammo.btConvexHullShape();

                objsR.forEach(function(objR) {
                    var positions = objR.geometry.attributes.position.array;

                    for (var i = 0; i < positions.length; i+=3) {
                        var x = positions[i];
                        var y = positions[i+1];
                        var z = positions[i+2];

                        var v = new Ammo.btVector3(x, y, z);

                        geometry.addPoint(v);

                        Ammo.destroy(v);
                    }
                });

            } else {

                var triIdxVertArray = new Ammo.btTriangleMesh();

                objsR.forEach(function(objR) {
                    var positions = objR.geometry.attributes.position.array;
                    var indices = objR.geometry.index.array;

                    for (var i = 0; i < indices.length; i+=3) {

                        var i1 = indices[i];
                        var i2 = indices[i+1];
                        var i3 = indices[i+2];

                        var v1 = new Ammo.btVector3(positions[3*i1], positions[3*i1+1], positions[3*i1+2]);
                        var v2 = new Ammo.btVector3(positions[3*i2], positions[3*i2+1], positions[3*i2+2]);
                        var v3 = new Ammo.btVector3(positions[3*i3], positions[3*i3+1], positions[3*i3+2]);

                        triIdxVertArray.addTriangle(v1, v2, v3, false);

                        Ammo.destroy(v1);
                        Ammo.destroy(v2);
                        Ammo.destroy(v3);
                    }
                });

                var geometry = new Ammo.btBvhTriangleMeshShape(triIdxVertArray, true);

            }

            break;
        }

        var pos = obj.getWorldPosition(_pGlob.vec3Tmp);
        var quat = obj.getWorldQuaternion(_pGlob.quatTmp);

        var transform = new Ammo.btTransform();
        transform.setIdentity();
        transform.setOrigin(new Ammo.btVector3(pos.x, pos.y, pos.z));
        transform.setRotation(new Ammo.btQuaternion(quat.x, quat.y, quat.z, quat.w));
        var motionState = new Ammo.btDefaultMotionState(transform);

        if (type == 'STATIC' || type == 'KINEMATIC' || type == 'GHOST')
            var bodyMass = 0;
        else
            var bodyMass = mass;

        var localInertia = new Ammo.btVector3(0, 0, 0);
        geometry.calculateLocalInertia(bodyMass, localInertia);

        var rbInfo = new Ammo.btRigidBodyConstructionInfo(bodyMass, motionState, geometry, localInertia);
        var body = new Ammo.btRigidBody(rbInfo);

        // CF_STATIC_OBJECT is set automatically

        if (type == 'KINEMATIC' || type == 'GHOST') {
            body.setCollisionFlags(body.getCollisionFlags() | CF_KINEMATIC_OBJECT);
            body.setActivationState(DISABLE_DEACTIVATION);
        }

        if (type == 'GHOST') {

            body.setCollisionFlags(body.getCollisionFlags() | CF_NO_CONTACT_RESPONSE);
            _pPhysics.world.addRigidBody(body, SensorTrigger, AllFilter);

        } else {

            _pPhysics.world.addRigidBody(body);

        }


        //body.setDamping(0.1, 0.1);

        _pPhysics.syncList.push({
            obj: obj,
            body: body,
            type: type,
            simulated: true,
            mass: mass
        });

    });


}




/**
 * Retrieve coordinate system from the loaded scene
 */
function getCoordSystem() {
    var scene = appInstance.scene;

    if (scene && "v3d" in scene.userData && "coordSystem" in scene.userData.v3d) {
        return scene.userData.v3d.coordSystem;
    } else {
        // COMPAT: <2.17, consider replacing to 'Y_UP_RIGHT' for scenes with unknown origin
        return 'Z_UP_RIGHT';
    }
}


/**
 * Transform coordinates from one space to another
 * Can be used with Vector3 or Euler.
 */
function coordsTransform(coords, from, to, noSignChange) {

    if (from == to)
        return coords;

    var y = coords.y, z = coords.z;

    if (from == 'Z_UP_RIGHT' && to == 'Y_UP_RIGHT') {
        coords.y = z;
        coords.z = noSignChange ? y : -y;
    } else if (from == 'Y_UP_RIGHT' && to == 'Z_UP_RIGHT') {
        coords.y = noSignChange ? z : -z;
        coords.z = y;
    } else {
        console.error('coordsTransform: Unsupported coordinate space');
    }

    return coords;
}


/**
 * Verge3D euler rotation to Blender/Max shortest.
 * 1) Convert from intrinsic rotation (v3d) to extrinsic XYZ (Blender/Max default
 *    order) via reversion: XYZ -> ZYX
 * 2) swizzle ZYX->YZX
 * 3) choose the shortest rotation to resemble Blender's behavior
 */
var eulerV3DToBlenderShortest = function() {

    var eulerTmp = new v3d.Euler();
    var eulerTmp2 = new v3d.Euler();
    var vec3Tmp = new v3d.Vector3();

    return function(euler, dest) {

        var eulerBlender = eulerTmp.copy(euler).reorder('YZX');
        var eulerBlenderAlt = eulerTmp2.copy(eulerBlender).makeAlternative();

        var len = eulerBlender.toVector3(vec3Tmp).lengthSq();
        var lenAlt = eulerBlenderAlt.toVector3(vec3Tmp).lengthSq();

        dest.copy(len < lenAlt ? eulerBlender : eulerBlenderAlt);
        return coordsTransform(dest, 'Y_UP_RIGHT', 'Z_UP_RIGHT');
    }

}();




// physicsApplyVector puzzle
function physicsApplyVector(type, objNames, x, y, z) {

    objNames = retrieveObjectNames(objNames);
    if (!objNames)
        return;

    var vec = _pGlob.vec3Tmp.set(x, y, z);

    var noSignChange = (type == 'LINEAR_FACTOR' || type == 'ANGULAR_FACTOR');
    coordsTransform(vec, getCoordSystem(), 'Y_UP_RIGHT', noSignChange);

    objNames.forEach(function(objName) {
        if (!objName)
            return;

        var obj = getObjectByName(objName);
        if (!obj)
            return;

        for (var i = 0; i < _pPhysics.syncList.length; i++) {
            var syncData = _pPhysics.syncList[i];

            if (syncData.obj == obj) {

                var btVec = new Ammo.btVector3(vec.x, vec.y, vec.z);

                switch (type) {
                case 'FORCE':
                    syncData.body.applyCentralForce(btVec);
                    break;
                case 'GRAVITY':
                    syncData.body.setGravity(btVec);
                    break;
                case 'LINEAR_VELOCITY':
                    syncData.body.setLinearVelocity(btVec);
                    break;
                case 'ANGULAR_VELOCITY':
                    syncData.body.setAngularVelocity(btVec);
                    break;
                case 'IMPULSE':
                    syncData.body.applyCentralImpulse(btVec);
                    break;
                case 'TORQUE':
                    syncData.body.applyTorque(btVec);
                    break;
                case 'TORQUE_IMPULSE':
                    syncData.body.applyTorqueImpulse(btVec);
                    break;
                case 'LINEAR_FACTOR':
                    syncData.body.setLinearFactor(btVec);
                    break;
                case 'ANGULAR_FACTOR':
                    syncData.body.setAngularFactor(btVec);
                    break;
                case 'POSITION':
                    _pPhysics.transTmp.setIdentity();
                    _pPhysics.transTmp.setOrigin(btVec);

                    var quat = obj.quaternion;
                    _pPhysics.transTmp.setRotation(new Ammo.btQuaternion(quat.x, quat.y, quat.z, quat.w));

                    syncData.body.setWorldTransform(_pPhysics.transTmp);

                    break;
                }

                Ammo.destroy(btVec);
            }
        }

    });


}


// Describe this function...
function Into_Room1() {
  unloadScene('Art_Gallery_room2.gltf');
  removePhysicsBody(['GROUP', 'Collision2']);
  createPhysicsBody('STATIC', ['GROUP', 'Collision1'], 'BOX', 1);
  appendScene('Art_Gallery_room1.gltf', 'Art_Gallery_room1.gltf', false, false, function() {
    EndPreloader();
    console.log('Room1 loaded！');
    outline(doors, 'ENABLE');
    physicsApplyVector('POSITION', 'character', 0, 0, 0);
  }, function() {
    UpdatePreloader(Math.round(_pGlob.percentage));
  });
}


// getObjDirection puzzle
function getObjDirection(objName, coord) {
    if (!objName)
        return;
    var obj = getObjectByName(objName);
    if (!obj)
        return;

    var dir = obj.getWorldDirection(_pGlob.vec3Tmp);

    var coordSystem = getCoordSystem();
    coordsTransform(dir, 'Y_UP_RIGHT', coordSystem);

    switch (coord) {
    case 'X':
        return dir.x;
    case 'Y':
        return dir.y;
    case 'Z':
        return dir.z;
    case 'XYZ':
        return dir.toArray();
    case 'HORIZONTAL':
        switch (coordSystem) {
        case 'Y_UP_RIGHT':
            dir.y = 0;
            dir.normalize();
            return [dir.x, 0, dir.z];
        default:
            dir.z = 0;
            dir.normalize();
            return [dir.x, dir.y, 0];
        }
    default:
        console.error("get object direction: Wrong coords");
        return;
    }
};



// setVectorValue puzzle
function setVectorValue(vector, valueName, value) {
    switch (valueName) {
    case 'X':
        vector[0] = value;
        break;
    case 'Y':
        vector[1] = value;
        break;
    case 'Z':
        vector[2] = value;
        break;
    case 'LENGTH':
        _pGlob.vec3Tmp.fromArray(vector).setLength(value).toArray(vector);
        break;
    }
}


// Describe this function...
function MoveForward(params) {
  if (mode_type == 'firstPerson') {
    if (params) {
      velocity = getObjDirection('Camera_fps', 'HORIZONTAL');
      setVectorValue(velocity, 'LENGTH', move_speed);
      console.log(params);
    } else {
      velocity = createVector(0, 0, 0);
      console.log(params);
    }
  }
}


// vectorMath puzzle
function vectorMath(vec1, operation, vec2) {

    var vec1 = _pGlob.vec3Tmp.fromArray(vec1);
    var vec2 = _pGlob.vec3Tmp2.fromArray(vec2);

    switch (operation) {
    case 'ADD':
        return vec1.add(vec2).toArray();
    case 'SUBTRACT':
        return vec1.sub(vec2).toArray();
    case 'MULTIPLY':
        return vec1.multiply(vec2).toArray();
    case 'DIVIDE':
        return vec1.divide(vec2).toArray();
    case 'DOT':
        return vec1.dot(vec2);
    case 'CROSS':
        return vec1.cross(vec2).toArray();
    case 'ROTATE':
        var euler = _pGlob.eulerTmp;
        vec2.multiplyScalar(Math.PI/180)
        return vec1.applyEuler(euler.setFromVector3(vec2)).toArray();
    default:
        console.error('vector math: Wrong operation');
        return;
    }
};


// Describe this function...
function MoveBack(params) {
  if (mode_type == 'firstPerson') {
    if (params) {
      velocity = vectorMath(getObjDirection('Camera_fps', 'HORIZONTAL'), 'ROTATE', createVector(0, 0, 180));
      setVectorValue(velocity, 'LENGTH', move_speed);
      console.log(params);
    } else {
      velocity = createVector(0, 0, 0);
      console.log(params);
    }
  }
}

// Describe this function...
function Into_Room2() {
  unloadScene('Art_Gallery_room1.gltf');
  removePhysicsBody(['GROUP', 'Collision1']);
  createPhysicsBody('STATIC', ['GROUP', 'Collision2'], 'BOX', 1);
  appendScene('Art_Gallery_room2.gltf', 'Art_Gallery_room2.gltf', false, false, function() {
    EndPreloader();
    console.log('Room2 loaded！');
    outline(doors, 'ENABLE');
    physicsApplyVector('POSITION', 'character', 0, 0, 0);
  }, function() {
    UpdatePreloader(Math.round(_pGlob.percentage));
  });
}

// Describe this function...
function MoveLeft(params) {
  if (mode_type == 'firstPerson') {
    if (params) {
      velocity = vectorMath(getObjDirection('Camera_fps', 'HORIZONTAL'), 'ROTATE', createVector(0, 0, 90));
      setVectorValue(velocity, 'LENGTH', move_speed);
      console.log(params);
    } else {
      velocity = createVector(0, 0, 0);
      console.log(params);
    }
  }
}


// utility functions envoked by the HTML puzzles
function getElements(ids, isParent) {
    var elems = [];
    if (Array.isArray(ids) && ids[0] != 'CONTAINER' && ids[0] != 'WINDOW' &&
        ids[0] != 'DOCUMENT' && ids[0] != 'BODY' && ids[0] != 'QUERYSELECTOR') {
        for (var i = 0; i < ids.length; i++)
            elems.push(getElement(ids[i], isParent));
    } else {
        elems.push(getElement(ids, isParent));
    }
    return elems;
}

function getElement(id, isParent) {
    var elem;
    if (Array.isArray(id) && id[0] == 'CONTAINER') {
        if (appInstance !== null) {
            elem = appInstance.container;
        } else if (typeof _initGlob !== 'undefined') {
            // if we are on the initialization stage, we still can have access
            // to the container element
            var id = _initGlob.container;
            if (isParent) {
                elem = parent.document.getElementById(id);
            } else {
                elem = document.getElementById(id);
            }
        }
    } else if (Array.isArray(id) && id[0] == 'WINDOW') {
        if (isParent)
            elem = parent;
        else
            elem = window;
    } else if (Array.isArray(id) && id[0] == 'DOCUMENT') {
        if (isParent)
            elem = parent.document;
        else
            elem = document;
    } else if (Array.isArray(id) && id[0] == 'BODY') {
        if (isParent)
            elem = parent.document.body;
        else
            elem = document.body;
    } else if (Array.isArray(id) && id[0] == 'QUERYSELECTOR') {
        if (isParent)
            elem = parent.document.querySelector(id);
        else
            elem = document.querySelector(id);
    } else {
        if (isParent)
            elem = parent.document.getElementById(id);
        else
            elem = document.getElementById(id);
    }
    return elem;
}



// setHTMLElemStyle puzzle
function setHTMLElemStyle(prop, value, ids, isParent) {
    var elems = getElements(ids, isParent);
    for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (!elem || !elem.style)
            continue;
        elem.style[prop] = value;
    }
}


// Describe this function...
function StartPreloader() {
  setHTMLElemStyle('display', 'block', 'preloader', false);
  setHTMLElemStyle('width', '0%', 'preloader_bar', false);
}

// Describe this function...
function UpdatePreloader(percenage) {
  setHTMLElemStyle('width', String(percenage) + '%', 'preloader_bar', false);
}

// Describe this function...
function EndPreloader() {
  setHTMLElemStyle('display', 'none', 'preloader', false);
}

// Describe this function...
function MoveRight(params) {
  if (mode_type == 'firstPerson') {
    if (params) {
      velocity = vectorMath(getObjDirection('Camera_fps', 'HORIZONTAL'), 'ROTATE', createVector(0, 0, -90));
      setVectorValue(velocity, 'LENGTH', move_speed);
      console.log(params);
    } else {
      velocity = createVector(0, 0, 0);
      console.log(params);
    }
  }
}


// getEventProperty puzzle
function getEventProperty(prop, event) {
    if (typeof event != "undefined") {
        if (prop == "target.id")
            return event.target.id;
        if (prop == "target.value")
            return event.target.value;
        else
            return event[prop];
    }
}



// eventHTMLElem puzzle
function eventHTMLElem(eventType, ids, isParent, callback) {
    var elems = getElements(ids, isParent);
    for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (!elem)
            continue;
        elem.addEventListener(eventType, callback, false);
    }
}



// setBodyState puzzle
function setBodyState(newState, objNames) {

    objNames = retrieveObjectNames(objNames);
    if (!objNames)
        return;

    objNames.forEach(function(objName) {
        if (!objName)
            return;

        var obj = getObjectByName(objName);
        if (!obj)
            return;

        for (var i = 0; i < _pPhysics.syncList.length; i++) {
            var syncData = _pPhysics.syncList[i];

            if (syncData.obj == obj) {

                var body = syncData.body;

                switch (newState) {
                case 'ACTIVATE':
                    body.activate();
                    break;
                case 'SLEEP':
                    body.setActivationState(ISLAND_SLEEPING);
                    break;
                case 'ENABLE_SIMULATION':
                    body.setCollisionFlags(body.getCollisionFlags() & ~CF_NO_CONTACT_RESPONSE);
                    body.forceActivationState(ACTIVE_TAG);
                    body.activate();

                    _pPhysics.setObjToBodyTransform(syncData.obj, body);

                    syncData.simulated = true;
                    break;
                case 'DISABLE_SIMULATION':
                    body.setCollisionFlags(body.getCollisionFlags() | CF_NO_CONTACT_RESPONSE);
                    body.forceActivationState(DISABLE_SIMULATION);
                    syncData.simulated = false;
                    break;
                case 'RESET':
                    _pPhysics.resetBody(body);
                    break;
                case 'ENABLE_CONTACT_RESP':
                    body.setCollisionFlags(body.getCollisionFlags() & ~CF_NO_CONTACT_RESPONSE);
                    break;
                case 'DISABLE_CONTACT_RESP':
                    body.setCollisionFlags(body.getCollisionFlags() | CF_NO_CONTACT_RESPONSE);
                    break;
                case 'MAKE_DYNAMIC':
                    body.setCollisionFlags(body.getCollisionFlags() & ~CF_KINEMATIC_OBJECT);
                    body.setCollisionFlags(body.getCollisionFlags() & ~CF_STATIC_OBJECT);

                    var localInertia = new Ammo.btVector3(0, 0, 0);
                    body.getCollisionShape().calculateLocalInertia(syncData.mass, localInertia);
                    body.setMassProps(syncData.mass, localInertia);

                    // enable deactivation
                    body.forceActivationState(ACTIVE_TAG);
                    body.activate();

                    break;
                case 'MAKE_KINEMATIC':
                    body.setCollisionFlags(body.getCollisionFlags() | CF_KINEMATIC_OBJECT);
                    body.setActivationState(DISABLE_DEACTIVATION);
                    break;
                case 'MAKE_STATIC':
                    body.setCollisionFlags(body.getCollisionFlags() | CF_STATIC_OBJECT);
                    break;
                case 'ENABLE_DEACTIVATION':
                    body.forceActivationState(ACTIVE_TAG);
                    break;
                case 'DISABLE_DEACTIVATION':
                    body.setActivationState(DISABLE_DEACTIVATION);
                    break;
                }

                // add / remove

            }

        }

    });
}



// getVectorValue puzzle
function getVectorValue(vector, value) {

    var vector = _pGlob.vec3Tmp.fromArray(vector);

    switch (value) {
    case 'X':
        return vector.x;
    case 'Y':
        return vector.y;
    case 'Z':
        return vector.z;
    case 'IS_ZERO':
        return Boolean(vector.length() <= Number.EPSILON);
    case 'LENGTH':
        return vector.length();
    case 'NEGATED':
        return [-vector.x, -vector.y, -vector.z];
    case 'NORMALIZED':
        return vector.normalize().toArray();
    default:
        console.error('get value from vector: Wrong value');
        return;
    }
};



// onSimulationTick puzzle
function onSimulationTick(tickType, tickCallback) {

    if (!_pPhysics.tickCallbacks.length) {
        var preTickCb = function(worldPtr, timeStep) {
            _pPhysics.tickCallbacks.forEach(function(pair) {
                if (pair[0] == 'BEFORE')
                    pair[1]();
            });
        }

        var tickCb = function(worldPtr, timeStep) {
            _pPhysics.tickCallbacks.forEach(function(pair) {
                if (pair[0] == 'AFTER')
                    pair[1]();
            });
        }

        _pPhysics.world.setInternalTickCallback(Ammo.addFunction(preTickCb, 'vif'), 0, true);
        _pPhysics.world.setInternalTickCallback(Ammo.addFunction(tickCb, 'vif'), 0, false);
    }

    _pPhysics.tickCallbacks.push([tickType, tickCallback]);

}


// Describe this function...
function Description(obj, description) {
  registerOnClick(obj, function() {
    getJSFunction('descModal')(description);
  }, function() {});
}


// loadVideo puzzle
function loadVideo(url) {
    var elems = _pGlob.mediaElements;
    if (!(url in elems)) {
        var elem = document.createElement('video');
        elem.src = url;
        elem.playsInline = true;
        elem.preload = 'auto';
        elem.autoload = true;
        elem.crossOrigin = 'anonymous';
        elems[url] = elem;
    }
    return elems[url];
}



/**
 * Retreive standard accessible textures for MeshNodeMaterial,
 * MeshStandardMaterial or MeshPhongMaterial. If "collectSameNameMats" is true
 * then all materials in the scene with the given name will be used for collecting
 * textures, otherwise will be used only the first found material (default behavior).
 */
function matGetEditableTextures(matName, collectSameNameMats) {

    var mats = [];
    if (collectSameNameMats) {
        mats = v3d.SceneUtils.getMaterialsByName(appInstance, matName);
    } else {
        var firstMat = v3d.SceneUtils.getMaterialByName(appInstance, matName);
        if (firstMat !== null) {
            mats = [firstMat];
        }
    }

    var textures = mats.reduce(function(texArray, mat) {
        var matTextures = [];
        switch (mat.type) {
            case 'MeshNodeMaterial':
                matTextures = Object.values(mat.nodeTextures);
                break;

            case 'MeshStandardMaterial':
                matTextures = [
                    mat.map, mat.lightMap, mat.aoMap, mat.emissiveMap,
                    mat.bumpMap, mat.normalMap, mat.displacementMap,
                    mat.roughnessMap, mat.metalnessMap, mat.alphaMap, mat.envMap
                ]
                break;

            case 'MeshPhongMaterial':
                matTextures = [
                    mat.map, mat.lightMap, mat.aoMap, mat.emissiveMap,
                    mat.bumpMap, mat.normalMap, mat.displacementMap,
                    mat.specularMap, mat.alphaMap, mat.envMap
                ];
                break;
            default:
                console.error('matGetEditableTextures: Unknown material type ' + mat.type);
                break;
        }

        Array.prototype.push.apply(texArray, matTextures);
        return texArray;
    }, []);

    return textures.filter(function(elem) {
        // check Texture type exactly
        return elem && (elem.constructor == v3d.Texture || elem.constructor == v3d.DataTexture);
    });
}



// replaceTexture puzzle
function replaceTexture(matName, texName, texUrlOrElem, doCb) {

    var textures = matGetEditableTextures(matName, true).filter(function(elem) {
        return elem.name == texName;
    });

    if (!textures.length)
        return;

    if (texUrlOrElem instanceof Promise) {

        texUrlOrElem.then(function(response) {
           processImageUrl(response);
        }, function(error) {});

    } else if (typeof texUrlOrElem == 'string') {

        processImageUrl(texUrlOrElem);

    } else if (texUrlOrElem instanceof HTMLVideoElement) {

        processVideo(texUrlOrElem);

    } else if (texUrlOrElem instanceof HTMLCanvasElement) {

        processCanvas(texUrlOrElem);

    } else {

        return;

    }

    function processImageUrl(url) {

        var isHDR = (url.search(/\.hdr$/) > 0);

        if (!isHDR) {
            var loader = new v3d.ImageLoader();
            loader.setCrossOrigin('Anonymous');
        } else {
            var loader = new v3d.FileLoader();
            loader.setResponseType('arraybuffer');
        }

        loader.load(url, function(image) {
            // JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.
            var isJPEG = url.search(/\.(jpg|jpeg)$/) > 0 || url.search(/^data\:image\/jpeg/) === 0;

            textures.forEach(function(elem) {

                if (!isHDR) {
                    elem.image = image;
                } else {
                    // parse loaded HDR buffer
                    var rgbeLoader = new v3d.RGBELoader();
                    var texData = rgbeLoader.parse(image);

                    // NOTE: reset params since the texture may be converted to float
                    elem.type = v3d.UnsignedByteType;
                    elem.encoding = v3d.RGBEEncoding;

                    elem.image = {
                        data: texData.data,
                        width: texData.width,
                        height: texData.height
                    }

                    elem.magFilter = v3d.LinearFilter;
                    elem.minFilter = v3d.LinearFilter;
                    elem.generateMipmaps = false;
                    elem.isDataTexture = true;

                }

                elem.format = isJPEG ? v3d.RGBFormat : v3d.RGBAFormat;
                elem.needsUpdate = true;

                // update world material if it is using this texture
                var wMat = appInstance.worldMaterial;
                if (wMat)
                    for (var texName in wMat.nodeTextures)
                        if (wMat.nodeTextures[texName] == elem)
                            appInstance.updateEnvironment(wMat);

            });

            // exec once
            doCb();

        });
    }

    function processVideo(elem) {
        var videoTex = new v3d.VideoTexture(elem);
        videoTex.flipY = false;
        videoTex.name = texName;

        var videoAssigned = false;

        var mats = v3d.SceneUtils.getMaterialsByName(appInstance, matName);
        mats.forEach(function(mat) {

            if (mat.type != 'MeshNodeMaterial')
                return;

            for (var name in mat.nodeTextures) {

                textures.forEach(function(tex) {

                    if (mat.nodeTextures[name] == tex) {
                        mat.nodeTextures[name] = videoTex;
                    }

                });

            }

            mat.needsUpdate = true;
            videoAssigned = true;
        });

        if (videoAssigned)
            doCb();

    }

    function processCanvas(elem) {
        var canvasTex = new v3d.CanvasTexture(elem);
        canvasTex.flipY = false;
        canvasTex.name = texName;

        var canvasAssigned = false;

        var mats = v3d.SceneUtils.getMaterialsByName(appInstance, matName);
        mats.forEach(function(mat) {

            if (mat.type != 'MeshNodeMaterial')
                return;

            for (var name in mat.nodeTextures) {

                textures.forEach(function(tex) {

                    if (mat.nodeTextures[name] == tex) {
                        mat.nodeTextures[name] = canvasTex;
                    }

                });

            }

            mat.needsUpdate = true;
            canvasAssigned = true;
        });

        if (canvasAssigned) {

            v3d.PL.canvasTextures = v3d.PL.canvasTextures || {};
            v3d.PL.canvasTextures[canvasTex.image.id] = canvasTex;

            doCb();
        }

    }
}



// playSound puzzle
function playSound(audioElem, loop) {
    if (!audioElem)
        return;
    audioElem.loop = loop;
    audioElem.play();
}



// pauseSound puzzle
function pauseSound(audioElem) {
    if (!audioElem)
        return;
    audioElem.pause();
}



doors = ['doorA', 'doorB', 'doorC', 'door_1', 'door_2', 'door_3', 'door_4'];
outline('Cube', 'ENABLE');

StartPreloader();
appendScene('Art_Gallery_room1.gltf', 'Art_Gallery_room1.gltf', false, false, function() {
  EndPreloader();
  console.log('Room1 loaded！');
  outline(doors, 'ENABLE');
}, function() {
  UpdatePreloader(Math.round(_pGlob.percentage));
});
registerOnClick(doors, function() {
  getJSFunction('clickObject')(_pGlob.pickedObject);
  console.log(_pGlob.pickedObject);
}, function() {});

snapToObject('Camera_fps', 'Head');
makeParent('Camera_fps', 'Head');

checkVRMode(function() {
  vr_available = true;
}, function() {
  vr_available = false;
});

if (featureAvailable('MOBILE')) {
  setScreenScale(window.devicePixelRatio);
}

mode_type = 'orbit';

velocity = createVector(0, 0, 0);
move_speed = 4;

eventHTMLElem('keydown', ['DOCUMENT'], true, function(event) {
  if (getEventProperty('key', event) == 'ArrowUp' || getEventProperty('key', event) == 'w') {
    MoveForward(true);
  }
});
eventHTMLElem('keydown', ['DOCUMENT'], true, function(event) {
  if (getEventProperty('key', event) == 'ArrowDown' || getEventProperty('key', event) == 's') {
    MoveBack(true);
  }
});
eventHTMLElem('keydown', ['DOCUMENT'], true, function(event) {
  if (getEventProperty('key', event) == 'ArrowLeft' || getEventProperty('key', event) == 'a') {
    MoveLeft(true);
  }
});
eventHTMLElem('keydown', ['DOCUMENT'], true, function(event) {
  if (getEventProperty('key', event) == 'ArrowRight' || getEventProperty('key', event) == 'd') {
    MoveRight(true);
  }
});
eventHTMLElem('keyup', ['DOCUMENT'], true, function(event) {
  if (getEventProperty('key', event) == 'ArrowUp' || getEventProperty('key', event) == 'w') {
    MoveForward(false);
  }
});
eventHTMLElem('keyup', ['DOCUMENT'], true, function(event) {
  if (getEventProperty('key', event) == 'ArrowDown' || getEventProperty('key', event) == 's') {
    MoveBack(false);
  }
});
eventHTMLElem('keyup', ['DOCUMENT'], true, function(event) {
  if (getEventProperty('key', event) == 'ArrowLeft' || getEventProperty('key', event) == 'a') {
    MoveLeft(false);
  }
});
eventHTMLElem('keyup', ['DOCUMENT'], true, function(event) {
  if (getEventProperty('key', event) == 'ArrowRight' || getEventProperty('key', event) == 'd') {
    MoveLeft(false);
  }
});



// TEMPORARY MEASURE TO PREVENT CRASH [TODO]
if (window.Ammo) {

var CF_STATIC_OBJECT = 1;
var CF_KINEMATIC_OBJECT = 2;
var CF_NO_CONTACT_RESPONSE = 4;

var ACTIVE_TAG = 1;
var ISLAND_SLEEPING = 2;
var DISABLE_DEACTIVATION = 4;
var DISABLE_SIMULATION = 5;

// collision filter groups
var DefaultFilter = 1;
var StaticFilter = 2;
var KinematicFilter = 4;
var DebrisFilter = 8;
var SensorTrigger = 16;
var CharacterFilter = 32;
var AllFilter = -1;

// createPhysicsWorld puzzle
_pPhysics.collisionConfiguration = new Ammo.btDefaultCollisionConfiguration();
_pPhysics.dispatcher = new Ammo.btCollisionDispatcher(_pPhysics.collisionConfiguration);
_pPhysics.broadphase = new Ammo.btDbvtBroadphase();
_pPhysics.solver = new Ammo.btSequentialImpulseConstraintSolver();
_pPhysics.world = new Ammo.btDiscreteDynamicsWorld(_pPhysics.dispatcher,
        _pPhysics.broadphase, _pPhysics.solver, _pPhysics.collisionConfiguration);
_pPhysics.world.setGravity( new Ammo.btVector3( 0, -9.8, 0 ) );
_pPhysics.fps = 120;
_pPhysics.transTmp = new Ammo.btTransform();

function tick(dt) {

    var DISTANCE_EPSILON = 0.000001;

    if (_pPhysics.collisionData.length) {

        var numManifolds = _pPhysics.world.getDispatcher().getNumManifolds();

        for (var i = 0; i < numManifolds; i++) {
            var contactManifold = _pPhysics.world.getDispatcher().getManifoldByIndexInternal(i);

            var bodyA = Ammo.castObject(contactManifold.getBody0(), Ammo.btRigidBody);
            var bodyB = Ammo.castObject(contactManifold.getBody1(), Ammo.btRigidBody);

            var collDataMatch = null;
            var objsSwapped = false;

            for (var j = 0; j < _pPhysics.collisionData.length; j++) {
                var cd = _pPhysics.collisionData[j];

                if (cd.bodyA == bodyA && cd.bodyB == bodyB) {
                    collDataMatch = cd;
                    break;
                }

                if (cd.bodyA == bodyB && cd.bodyB == bodyA) {
                    collDataMatch = cd;
                    objsSwapped = true;
                    break;
                }
            }

            if (!collDataMatch)
                continue;

            var numContacts = contactManifold.getNumContacts();

            for (var j = 0; j < numContacts; j++) {
                var pt = contactManifold.getContactPoint(j);

                if (pt.getDistance() < DISTANCE_EPSILON) {
                    var ptA = pt.getPositionWorldOnA();
                    var ptB = pt.getPositionWorldOnB();
                    var noB = pt.get_m_normalWorldOnB();

                    _pPhysics.collisionInfo.objectA = collDataMatch.objA ? getPickedObjectName(collDataMatch.objA) : '';
                    _pPhysics.collisionInfo.objectB = collDataMatch.objB ? getPickedObjectName(collDataMatch.objB) : '';

                    _pPhysics.collisionInfo.distance = pt.getDistance();

                    if (!objsSwapped) {
                        _pPhysics.collisionInfo.positionOnA[0] = ptA.x();
                        _pPhysics.collisionInfo.positionOnA[1] = ptA.y();
                        _pPhysics.collisionInfo.positionOnA[2] = ptA.z();

                        _pPhysics.collisionInfo.positionOnB[0] = ptB.x();
                        _pPhysics.collisionInfo.positionOnB[1] = ptB.y();
                        _pPhysics.collisionInfo.positionOnB[2] = ptB.z();

                        _pPhysics.collisionInfo.normalOnB[0] = noB.x();
                        _pPhysics.collisionInfo.normalOnB[1] = noB.y();
                        _pPhysics.collisionInfo.normalOnB[2] = noB.z();
                    } else {
                        _pPhysics.collisionInfo.positionOnA[0] = ptB.x();
                        _pPhysics.collisionInfo.positionOnA[1] = ptB.y();
                        _pPhysics.collisionInfo.positionOnA[2] = ptB.z();

                        _pPhysics.collisionInfo.positionOnB[0] = ptA.x();
                        _pPhysics.collisionInfo.positionOnB[1] = ptA.y();
                        _pPhysics.collisionInfo.positionOnB[2] = ptA.z();

                        _pPhysics.collisionInfo.normalOnB[0] = -noB.x();
                        _pPhysics.collisionInfo.normalOnB[1] = -noB.y();
                        _pPhysics.collisionInfo.normalOnB[2] = -noB.z();
                    }

                    collDataMatch.collideCb();
                    collDataMatch.collideFlag = true;
                }
            }
        }

        for (var i = 0; i < _pPhysics.collisionData.length; i++) {
            var cd = _pPhysics.collisionData[i];

            if (!cd.collideFlag) {
                _pPhysics.collisionInfo.objectA = '';
                _pPhysics.collisionInfo.objectB = '';

                _pPhysics.collisionInfo.distance = 0;

                _pPhysics.collisionInfo.positionOnA[0] = 0;
                _pPhysics.collisionInfo.positionOnA[1] = 0;
                _pPhysics.collisionInfo.positionOnA[2] = 0;

                _pPhysics.collisionInfo.positionOnB[0] = 0;
                _pPhysics.collisionInfo.positionOnB[1] = 0;
                _pPhysics.collisionInfo.positionOnB[2] = 0;

                _pPhysics.collisionInfo.normalOnB[0] = 0;
                _pPhysics.collisionInfo.normalOnB[1] = 0;
                _pPhysics.collisionInfo.normalOnB[2] = 0;

                cd.noCollideCb();
            }

            cd.collideFlag = false;
        }
    }

    _pPhysics.world.stepSimulation(dt, 10, 1/120);

    // sync physics and graphics

    for (var i = 0; i < _pPhysics.syncList.length; i++) {
        var syncData = _pPhysics.syncList[i];
        if (!syncData.simulated)
            continue;

        var body = syncData.body;

        if (!body.isStaticOrKinematicObject()) {
            var ms = body.getMotionState();
            if (ms) {
                ms.getWorldTransform(_pPhysics.transTmp);
                var p = _pPhysics.transTmp.getOrigin();
                var q = _pPhysics.transTmp.getRotation();
                // dynamic objects can't be parented to something
                syncData.obj.position.set(p.x(), p.y(), p.z());
                syncData.obj.quaternion.set(q.x(), q.y(), q.z(), q.w());
            }

        } else if (body.isKinematicObject()) {

            var pos = syncData.obj.getWorldPosition(_pGlob.vec3Tmp);
            var quat = syncData.obj.getWorldQuaternion(_pGlob.quatTmp);

            _pPhysics.transTmp.setIdentity();
            _pPhysics.transTmp.setOrigin(new Ammo.btVector3(pos.x, pos.y, pos.z));
            _pPhysics.transTmp.setRotation(new Ammo.btQuaternion(quat.x, quat.y, quat.z, quat.w));

            body.setWorldTransform(_pPhysics.transTmp);

            // needed to calculate interpolated velocity
            body.getMotionState().setWorldTransform(_pPhysics.transTmp);

        }
    }

}

appInstance.renderCallbacks.push(tick);

// END OF TEMPORARY MEASURE TO PREVENT CRASH [TODO]
}


createPhysicsBody('STATIC', ['GROUP', 'Collision1'], 'BOX', 1);
createPhysicsBody('STATIC', 'Plane', 'MESH', 1);
createPhysicsBody('DYNAMIC', 'character', 'CAPSULE', 60);
physicsApplyVector('ANGULAR_FACTOR', 'character', 0, 0, 0);
setBodyState('DISABLE_DEACTIVATION', 'character');

onSimulationTick('BEFORE', function() {
  physicsApplyVector('LINEAR_VELOCITY', 'character', getVectorValue(velocity, 'X'), getVectorValue(velocity, 'Y'), getVectorValue(velocity, 'Z'));
});

Description('Photo_01', '<p>清明上河图（Along the River During the Qingming Festival ）：Along the River During the Qingming Festival, also known by its Chinese name as the Qingming Shanghe Tu, is a painting by the Song dynasty painter Zhang Zeduan. It captures the daily life of people and the landscape of the capital, Bianjing during the Northern Song.</p>');
Description('Photo_02', '<p>五牛图（Five Buffalos）：This painting was painted by Huang Han in Tang dynasty. This is one buffalo in five buffalos from this painting, which has 139.8 cm long. This painting is famous of Huang Han’s excellent ability to depict realistically.</p>');
Description('Photo_03', '<p>沁园春雪： Snow Adopted After the Tune of Chin Yuan Chun Mao Zedong North country scene: A hundred leagues locked in ice, A thousand leagues of whirling snow. Both sides of the Great Wall One single white immensity. The Yellow River\'s swift current Is stilled from end to end. The mountains dance like silver snakes And the highlands charge like wax-hued elephants, Vying with heaven in stature. On a fine day, the land, Clad in white, adorned in red, Grows more enchanting. This land so rich in beauty Has made countless heroes bow in homage. But alas! Chin Shih-huang and Han Wu-ti Were lacking in literary grace, And Tang Tai-tsung and Sung Tai-tsu Had little poetry in their souls; And Genghis Khan, Proud Son of Heaven for a day, Knew only shooting eagles, bow outstretched All are past and gone! For truly great men Look to this age alone.</p>');
Description('Photo_04', '<p>富春山居图（Dwelling in the Fuchun Mountains）：Dwelling in the Fuchun Mountains is one of the few surviving works by painter Huang Gongwang and it is considered to be among his greatest works. Painted between 1348 and 1420, the Chinese landscape painting was burnt into two pieces in 1650.</p>');
Description('Photo_05', '<p>沁园春雪： Snow Adopted After the Tune of Chin Yuan Chun Mao Zedong North country scene: A hundred leagues locked in ice, A thousand leagues of whirling snow. Both sides of the Great Wall One single white immensity. The Yellow River\'s swift current Is stilled from end to end. The mountains dance like silver snakes And the highlands charge like wax-hued elephants, Vying with heaven in stature. On a fine day, the land, Clad in white, adorned in red, Grows more enchanting. This land so rich in beauty Has made countless heroes bow in homage. But alas! Chin Shih-huang and Han Wu-ti Were lacking in literary grace, And Tang Tai-tsung and Sung Tai-tsu Had little poetry in their souls; And Genghis Khan, Proud Son of Heaven for a day, Knew only shooting eagles, bow outstretched All are past and gone! For truly great men Look to this age alone.</p>');
Description('Photo_06', '<p>千里江山图（A Thousand Li of Rivers and Mountains ）：Wang\'s only surviving work. The painting, finished by Wang when he was only 18 in 1113, as one of the largest in Chinese history, and has been described as one of the greatest works of Chinese art. The painting is in the permanent collection of the Palace Museum in Beijing.</p>');
Description('Photo_07', '<p>汉宫春晓图（Spring morning in the Han Palace ）：Spring Morning in the Han Palace (漢宮春曉) Qiu Ying (仇英, ca. 1494-1552), Ming Dynasty (1368-1644) Handscroll, ink and colors on silk, 30.6 x 574.1 cm, National Palace Museum, Taipei. This long handscroll work is an imaginary representation of various activities in a Han dynasty (206 BC-AD 220) palace on a spring morning.</p>');
Description('Photo_08', '<p>步辇图（Emperor Taizong Receiving the Tibetan Envoy ）：Emperor Taizong Receiving the Tibetan Envoy is a painting on silk by Yan Liben to show the friendly encounter between the Tang dynasty and Tibet. The painting is 129 centimetres long by 38.5 centimetres wide. Bunian Tu is in The Palace Museum in Beijing.</p>');
Description('Photo_09', '<p>韩熙载夜宴图（The Night Revels of Han Xizai）：The Night Revels of Han Xizai or The Night Entertainments of Han Xizai is a painted handscroll attributed to Chinese 10th-century artist Gu Hongzhong. It survived as a copy made during the Song dynasty.</p>');
Description('Photo_10', '<p>百骏图（One Hundred Horses）：Giuseppe Castiglione achieved marvelous results in painting during the Yongzheng reign (1723-1735), his monumental masterpiece of "One Hundred Horses" being completed then. This long handscroll depicts a hundred steeds by a riverbank, the horses appearing in different manners and poses.</p>');

Description('photo_1', '<p>This photo is shoot by Jenny Su. The Sydney Opera House is a multi-venue performing arts centre at Sydney Harbour located in Sydney, New South Wales, Australia. It is one of the 20th century\'s most famous and distinctive buildings.</p>');
Description('photo_2', '<p>The Starry Night is an oil on canvas painting by Dutch Post-Impressionist painter Vincent van Gogh. Painted in June 1889, it depicts the view from the east-facing window of his asylum room at Saint-Rémy-de-Provence, just before sunrise, with the addition of an imaginary village.</p>');
Description('photo_3', '<p>Girl with a Pearl Earring is an oil painting by Dutch Golden Age painter Johannes Vermeer, dated c. 1665. Going by various names over the centuries, it became known by its present title towards the end of the 20th century after the large pearl earring worn by the girl portrayed there.</p>');
Description('photo_4', '<p>This photo is shoot by Jenny Su. Tower Bridge is a combined bascule and suspension bridge in London, built between 1886 and 1894. The bridge crosses the River Thames close to the Tower of London and has become a world-famous symbol of London. As a result, it is sometimes confused with London Bridge, about half a mile upstream.</p>');
Description('photo_5', '<p>This photo is shoot by Jenny Su. This is a beautiful village.</p>');
Description('Venus', '<p>The Venus de Milo is an ancient Greek statue and one of the most famous works of ancient Greek sculpture. Initially it was attributed to the sculptor Praxiteles, but based on an inscription that was on its plinth, the statue is now thought to be the work of Alexandros of Antioch. Created sometime between 130 and 100 BC, the statue is believed to depict Aphrodite, the Greek goddess of love and beauty, although some scholars claim it is the sea-goddess Amphitrite, venerated on Milos. It is a marble sculpture, slightly larger than life size at 203 cm (6 ft 8 in) high. Part of an arm and the original plinth were lost following the statue\'s discovery. It is currently on permanent display at the Louvre Museum in Paris.</p>');
Description('Thinker', '<p>The Thinker is a bronze sculpture by Auguste Rodin, usually placed on a stone pedestal. The work shows a nude male figure of heroic size sitting on a rock resting on his chin on one hand as though deep in thought, often used as an image to represent philosophy. There are about 28 full-sized castings, in which the figure is about 73 inches high, though not all were made during Rodin\'s lifetime and under his supervision.</p>');

play = false;
video1 = loadVideo('./The animation of VAN GOGH\'s starry night.mp4');
video2 = loadVideo('./video.mp4');

registerOnClick('screen', function() {
  if (play == false) {
    replaceTexture('mat_screen', 'texture_for_video', video1, function() {});
    playSound(video1, true);
    play = true;
  } else {
    replaceTexture('mat_screen', 'texture_for_video', './tap_here_texture.png', function() {});
    pauseSound(video1);
    play = false;
  }
}, function() {});
registerOnClick('tv_screen', function() {
  if (play == false) {
    replaceTexture('tv_screen', 'texture_for_video', video2, function() {});
    playSound(video2, true);
    play = true;
  } else {
    replaceTexture('tv_screen', 'texture_for_video', './tap_here_texture.png', function() {});
    pauseSound(video2);
    play = false;
  }
}, function() {});



} // end of PL.init function

})(); // end of closure

/* ================================ end of code ============================= */
